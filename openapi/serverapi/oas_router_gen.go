// Code generated by ogen, DO NOT EDIT.

package serverapi

import (
	"net/http"
	"net/url"
	"strings"

	"github.com/ogen-go/ogen/uri"
)

func (s *Server) cutPrefix(path string) (string, bool) {
	prefix := s.cfg.Prefix
	if prefix == "" {
		return path, true
	}
	if !strings.HasPrefix(path, prefix) {
		// Prefix doesn't match.
		return "", false
	}
	// Cut prefix from the path.
	return strings.TrimPrefix(path, prefix), true
}

// ServeHTTP serves http request as defined by OpenAPI v3 specification,
// calling handler that matches the path or returning not found error.
func (s *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	elem := r.URL.Path
	elemIsEscaped := false
	if rawPath := r.URL.RawPath; rawPath != "" {
		if normalized, ok := uri.NormalizeEscapedPath(rawPath); ok {
			elem = normalized
			elemIsEscaped = strings.ContainsRune(elem, '%')
		}
	}

	elem, ok := s.cutPrefix(elem)
	if !ok || len(elem) == 0 {
		s.notFound(w, r)
		return
	}
	args := [1]string{}

	// Static code generated router with unwrapped path search.
	switch {
	default:
		if len(elem) == 0 {
			break
		}
		switch elem[0] {
		case '/': // Prefix: "/api/"

			if l := len("/api/"); len(elem) >= l && elem[0:l] == "/api/" {
				elem = elem[l:]
			} else {
				break
			}

			if len(elem) == 0 {
				break
			}
			switch elem[0] {
			case 'a': // Prefix: "a"

				if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'g': // Prefix: "gent/"

					if l := len("gent/"); len(elem) >= l && elem[0:l] == "gent/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'd': // Prefix: "delete"

						if l := len("delete"); len(elem) >= l && elem[0:l] == "delete" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "POST":
								s.handleAPIAgentDeletePostRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "POST")
							}

							return
						}

					case 'g': // Prefix: "get"

						if l := len("get"); len(elem) >= l && elem[0:l] == "get" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "POST":
								s.handleAPIAgentGetPostRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "POST")
							}

							return
						}

					case 'l': // Prefix: "list"

						if l := len("list"); len(elem) >= l && elem[0:l] == "list" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "POST":
								s.handleAPIAgentListPostRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "POST")
							}

							return
						}

					case 'n': // Prefix: "new"

						if l := len("new"); len(elem) >= l && elem[0:l] == "new" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "POST":
								s.handleAPIAgentNewPostRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "POST")
							}

							return
						}

					case 't': // Prefix: "task/export"

						if l := len("task/export"); len(elem) >= l && elem[0:l] == "task/export" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "POST":
								s.handleAPIAgentTaskExportPostRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "POST")
							}

							return
						}

					case 'u': // Prefix: "update"

						if l := len("update"); len(elem) >= l && elem[0:l] == "update" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "POST":
								s.handleAPIAgentUpdatePostRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "POST")
							}

							return
						}

					}

				case 't': // Prefix: "ttribute/"

					if l := len("ttribute/"); len(elem) >= l && elem[0:l] == "ttribute/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'c': // Prefix: "co"

						if l := len("co"); len(elem) >= l && elem[0:l] == "co" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'l': // Prefix: "lor/"

							if l := len("lor/"); len(elem) >= l && elem[0:l] == "lor/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'c': // Prefix: "create"

								if l := len("create"); len(elem) >= l && elem[0:l] == "create" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "POST":
										s.handleAPIAttributeColorCreatePostRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}

							case 'd': // Prefix: "delete"

								if l := len("delete"); len(elem) >= l && elem[0:l] == "delete" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "POST":
										s.handleAPIAttributeColorDeletePostRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}

							case 'g': // Prefix: "get"

								if l := len("get"); len(elem) >= l && elem[0:l] == "get" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "POST":
										s.handleAPIAttributeColorGetPostRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}

							case 'l': // Prefix: "list"

								if l := len("list"); len(elem) >= l && elem[0:l] == "list" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleAPIAttributeColorListGetRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}

							case 'u': // Prefix: "update"

								if l := len("update"); len(elem) >= l && elem[0:l] == "update" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "POST":
										s.handleAPIAttributeColorUpdatePostRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}

							}

						case 'u': // Prefix: "unt"

							if l := len("unt"); len(elem) >= l && elem[0:l] == "unt" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleAPIAttributeCountGetRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}

						}

					case 'o': // Prefix: "origin/count"

						if l := len("origin/count"); len(elem) >= l && elem[0:l] == "origin/count" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "GET":
								s.handleAPIAttributeOriginCountGetRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}

					case 'r': // Prefix: "remap/"

						if l := len("remap/"); len(elem) >= l && elem[0:l] == "remap/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'c': // Prefix: "create"

							if l := len("create"); len(elem) >= l && elem[0:l] == "create" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "POST":
									s.handleAPIAttributeRemapCreatePostRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "POST")
								}

								return
							}

						case 'd': // Prefix: "delete"

							if l := len("delete"); len(elem) >= l && elem[0:l] == "delete" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "POST":
									s.handleAPIAttributeRemapDeletePostRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "POST")
								}

								return
							}

						case 'g': // Prefix: "get"

							if l := len("get"); len(elem) >= l && elem[0:l] == "get" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "POST":
									s.handleAPIAttributeRemapGetPostRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "POST")
								}

								return
							}

						case 'l': // Prefix: "list"

							if l := len("list"); len(elem) >= l && elem[0:l] == "list" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleAPIAttributeRemapListGetRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}

						case 'u': // Prefix: "update"

							if l := len("update"); len(elem) >= l && elem[0:l] == "update" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "POST":
									s.handleAPIAttributeRemapUpdatePostRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "POST")
								}

								return
							}

						}

					}

				}

			case 'b': // Prefix: "book/"

				if l := len("book/"); len(elem) >= l && elem[0:l] == "book/" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'a': // Prefix: "archive/"

					if l := len("archive/"); len(elem) >= l && elem[0:l] == "archive/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "id"
					// Leaf parameter, slashes are prohibited
					idx := strings.IndexByte(elem, '/')
					if idx >= 0 {
						break
					}
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "GET":
							s.handleAPIBookArchiveIDGetRequest([1]string{
								args[0],
							}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "GET")
						}

						return
					}

				case 'd': // Prefix: "de"

					if l := len("de"); len(elem) >= l && elem[0:l] == "de" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'l': // Prefix: "lete"

						if l := len("lete"); len(elem) >= l && elem[0:l] == "lete" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "POST":
								s.handleAPIBookDeletePostRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "POST")
							}

							return
						}

					case 't': // Prefix: "tails"

						if l := len("tails"); len(elem) >= l && elem[0:l] == "tails" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "POST":
								s.handleAPIBookDetailsPostRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "POST")
							}

							return
						}

					}

				case 'l': // Prefix: "list"

					if l := len("list"); len(elem) >= l && elem[0:l] == "list" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "POST":
							s.handleAPIBookListPostRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "POST")
						}

						return
					}

				case 'p': // Prefix: "page/"

					if l := len("page/"); len(elem) >= l && elem[0:l] == "page/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'b': // Prefix: "body"

						if l := len("body"); len(elem) >= l && elem[0:l] == "body" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "POST":
								s.handleAPIBookPageBodyPostRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "POST")
							}

							return
						}

					case 'd': // Prefix: "delete"

						if l := len("delete"); len(elem) >= l && elem[0:l] == "delete" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "POST":
								s.handleAPIBookPageDeletePostRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "POST")
							}

							return
						}

					}

				case 'r': // Prefix: "r"

					if l := len("r"); len(elem) >= l && elem[0:l] == "r" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'a': // Prefix: "aw"

						if l := len("aw"); len(elem) >= l && elem[0:l] == "aw" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "POST":
								s.handleAPIBookRawPostRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "POST")
							}

							return
						}

					case 'e': // Prefix: "e"

						if l := len("e"); len(elem) >= l && elem[0:l] == "e" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'b': // Prefix: "build"

							if l := len("build"); len(elem) >= l && elem[0:l] == "build" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "POST":
									s.handleAPIBookRebuildPostRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "POST")
								}

								return
							}

						case 's': // Prefix: "store"

							if l := len("store"); len(elem) >= l && elem[0:l] == "store" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "POST":
									s.handleAPIBookRestorePostRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "POST")
								}

								return
							}

						}

					}

				case 's': // Prefix: "status/set"

					if l := len("status/set"); len(elem) >= l && elem[0:l] == "status/set" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "POST":
							s.handleAPIBookStatusSetPostRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "POST")
						}

						return
					}

				case 'u': // Prefix: "update"

					if l := len("update"); len(elem) >= l && elem[0:l] == "update" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "POST":
							s.handleAPIBookUpdatePostRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "POST")
						}

						return
					}

				}

			case 'd': // Prefix: "deduplicate/"

				if l := len("deduplicate/"); len(elem) >= l && elem[0:l] == "deduplicate/" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'a': // Prefix: "archive"

					if l := len("archive"); len(elem) >= l && elem[0:l] == "archive" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "POST":
							s.handleAPIDeduplicateArchivePostRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "POST")
						}

						return
					}

				case 'b': // Prefix: "book"

					if l := len("book"); len(elem) >= l && elem[0:l] == "book" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '-': // Prefix: "-by-page-body"

						if l := len("-by-page-body"); len(elem) >= l && elem[0:l] == "-by-page-body" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "POST":
								s.handleAPIDeduplicateBookByPageBodyPostRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "POST")
							}

							return
						}

					case 's': // Prefix: "s-by-page"

						if l := len("s-by-page"); len(elem) >= l && elem[0:l] == "s-by-page" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "POST":
								s.handleAPIDeduplicateBooksByPagePostRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "POST")
							}

							return
						}

					}

				case 'c': // Prefix: "compare"

					if l := len("compare"); len(elem) >= l && elem[0:l] == "compare" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "POST":
							s.handleAPIDeduplicateComparePostRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "POST")
						}

						return
					}

				case 'd': // Prefix: "dead-hash/set"

					if l := len("dead-hash/set"); len(elem) >= l && elem[0:l] == "dead-hash/set" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "POST":
							s.handleAPIDeduplicateDeadHashSetPostRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "POST")
						}

						return
					}

				case 'u': // Prefix: "unique-pages"

					if l := len("unique-pages"); len(elem) >= l && elem[0:l] == "unique-pages" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "POST":
							s.handleAPIDeduplicateUniquePagesPostRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "POST")
						}

						return
					}

				}

			case 'f': // Prefix: "f"

				if l := len("f"); len(elem) >= l && elem[0:l] == "f" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'i': // Prefix: "ile/"

					if l := len("ile/"); len(elem) >= l && elem[0:l] == "ile/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "id"
					// Leaf parameter, slashes are prohibited
					idx := strings.IndexByte(elem, '/')
					if idx >= 0 {
						break
					}
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "GET":
							s.handleAPIFileIDGetRequest([1]string{
								args[0],
							}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "GET")
						}

						return
					}

				case 's': // Prefix: "s/"

					if l := len("s/"); len(elem) >= l && elem[0:l] == "s/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'c': // Prefix: "create"

						if l := len("create"); len(elem) >= l && elem[0:l] == "create" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "POST":
								s.handleAPIFsCreatePostRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "POST")
							}

							return
						}

					case 'd': // Prefix: "delete"

						if l := len("delete"); len(elem) >= l && elem[0:l] == "delete" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "POST":
								s.handleAPIFsDeletePostRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "POST")
							}

							return
						}

					case 'g': // Prefix: "get"

						if l := len("get"); len(elem) >= l && elem[0:l] == "get" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "POST":
								s.handleAPIFsGetPostRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "POST")
							}

							return
						}

					case 'l': // Prefix: "list"

						if l := len("list"); len(elem) >= l && elem[0:l] == "list" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "POST":
								s.handleAPIFsListPostRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "POST")
							}

							return
						}

					case 'r': // Prefix: "remove-mismatch"

						if l := len("remove-mismatch"); len(elem) >= l && elem[0:l] == "remove-mismatch" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "POST":
								s.handleAPIFsRemoveMismatchPostRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "POST")
							}

							return
						}

					case 't': // Prefix: "transfer"

						if l := len("transfer"); len(elem) >= l && elem[0:l] == "transfer" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch r.Method {
							case "POST":
								s.handleAPIFsTransferPostRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "POST")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/book"

							if l := len("/book"); len(elem) >= l && elem[0:l] == "/book" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "POST":
									s.handleAPIFsTransferBookPostRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "POST")
								}

								return
							}

						}

					case 'u': // Prefix: "update"

						if l := len("update"); len(elem) >= l && elem[0:l] == "update" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "POST":
								s.handleAPIFsUpdatePostRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "POST")
							}

							return
						}

					case 'v': // Prefix: "validate"

						if l := len("validate"); len(elem) >= l && elem[0:l] == "validate" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "POST":
								s.handleAPIFsValidatePostRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "POST")
							}

							return
						}

					}

				}

			case 'h': // Prefix: "hproxy/"

				if l := len("hproxy/"); len(elem) >= l && elem[0:l] == "hproxy/" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'b': // Prefix: "book"

					if l := len("book"); len(elem) >= l && elem[0:l] == "book" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "POST":
							s.handleAPIHproxyBookPostRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "POST")
						}

						return
					}

				case 'f': // Prefix: "file"

					if l := len("file"); len(elem) >= l && elem[0:l] == "file" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "GET":
							s.handleAPIHproxyFileGetRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "GET")
						}

						return
					}

				case 'l': // Prefix: "list"

					if l := len("list"); len(elem) >= l && elem[0:l] == "list" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "POST":
							s.handleAPIHproxyListPostRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "POST")
						}

						return
					}

				}

			case 'l': // Prefix: "label/"

				if l := len("label/"); len(elem) >= l && elem[0:l] == "label/" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'd': // Prefix: "delete"

					if l := len("delete"); len(elem) >= l && elem[0:l] == "delete" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "POST":
							s.handleAPILabelDeletePostRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "POST")
						}

						return
					}

				case 'g': // Prefix: "get"

					if l := len("get"); len(elem) >= l && elem[0:l] == "get" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "POST":
							s.handleAPILabelGetPostRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "POST")
						}

						return
					}

				case 'p': // Prefix: "preset/"

					if l := len("preset/"); len(elem) >= l && elem[0:l] == "preset/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'c': // Prefix: "create"

						if l := len("create"); len(elem) >= l && elem[0:l] == "create" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "POST":
								s.handleAPILabelPresetCreatePostRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "POST")
							}

							return
						}

					case 'd': // Prefix: "delete"

						if l := len("delete"); len(elem) >= l && elem[0:l] == "delete" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "POST":
								s.handleAPILabelPresetDeletePostRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "POST")
							}

							return
						}

					case 'g': // Prefix: "get"

						if l := len("get"); len(elem) >= l && elem[0:l] == "get" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "POST":
								s.handleAPILabelPresetGetPostRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "POST")
							}

							return
						}

					case 'l': // Prefix: "list"

						if l := len("list"); len(elem) >= l && elem[0:l] == "list" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "GET":
								s.handleAPILabelPresetListGetRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}

					case 'u': // Prefix: "update"

						if l := len("update"); len(elem) >= l && elem[0:l] == "update" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "POST":
								s.handleAPILabelPresetUpdatePostRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "POST")
							}

							return
						}

					}

				case 's': // Prefix: "set"

					if l := len("set"); len(elem) >= l && elem[0:l] == "set" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "POST":
							s.handleAPILabelSetPostRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "POST")
						}

						return
					}

				}

			case 'm': // Prefix: "massload/"

				if l := len("massload/"); len(elem) >= l && elem[0:l] == "massload/" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'f': // Prefix: "flag/"

					if l := len("flag/"); len(elem) >= l && elem[0:l] == "flag/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'c': // Prefix: "create"

						if l := len("create"); len(elem) >= l && elem[0:l] == "create" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "POST":
								s.handleAPIMassloadFlagCreatePostRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "POST")
							}

							return
						}

					case 'd': // Prefix: "delete"

						if l := len("delete"); len(elem) >= l && elem[0:l] == "delete" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "POST":
								s.handleAPIMassloadFlagDeletePostRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "POST")
							}

							return
						}

					case 'g': // Prefix: "get"

						if l := len("get"); len(elem) >= l && elem[0:l] == "get" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "POST":
								s.handleAPIMassloadFlagGetPostRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "POST")
							}

							return
						}

					case 'l': // Prefix: "list"

						if l := len("list"); len(elem) >= l && elem[0:l] == "list" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "GET":
								s.handleAPIMassloadFlagListGetRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}

					case 'u': // Prefix: "update"

						if l := len("update"); len(elem) >= l && elem[0:l] == "update" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "POST":
								s.handleAPIMassloadFlagUpdatePostRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "POST")
							}

							return
						}

					}

				case 'i': // Prefix: "info/"

					if l := len("info/"); len(elem) >= l && elem[0:l] == "info/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'a': // Prefix: "attribute/"

						if l := len("attribute/"); len(elem) >= l && elem[0:l] == "attribute/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'c': // Prefix: "create"

							if l := len("create"); len(elem) >= l && elem[0:l] == "create" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "POST":
									s.handleAPIMassloadInfoAttributeCreatePostRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "POST")
								}

								return
							}

						case 'd': // Prefix: "delete"

							if l := len("delete"); len(elem) >= l && elem[0:l] == "delete" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "POST":
									s.handleAPIMassloadInfoAttributeDeletePostRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "POST")
								}

								return
							}

						}

					case 'c': // Prefix: "create"

						if l := len("create"); len(elem) >= l && elem[0:l] == "create" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "POST":
								s.handleAPIMassloadInfoCreatePostRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "POST")
							}

							return
						}

					case 'd': // Prefix: "delete"

						if l := len("delete"); len(elem) >= l && elem[0:l] == "delete" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "POST":
								s.handleAPIMassloadInfoDeletePostRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "POST")
							}

							return
						}

					case 'e': // Prefix: "external_link/"

						if l := len("external_link/"); len(elem) >= l && elem[0:l] == "external_link/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'c': // Prefix: "create"

							if l := len("create"); len(elem) >= l && elem[0:l] == "create" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "POST":
									s.handleAPIMassloadInfoExternalLinkCreatePostRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "POST")
								}

								return
							}

						case 'd': // Prefix: "delete"

							if l := len("delete"); len(elem) >= l && elem[0:l] == "delete" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "POST":
									s.handleAPIMassloadInfoExternalLinkDeletePostRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "POST")
								}

								return
							}

						case 'u': // Prefix: "update"

							if l := len("update"); len(elem) >= l && elem[0:l] == "update" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "POST":
									s.handleAPIMassloadInfoExternalLinkUpdatePostRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "POST")
								}

								return
							}

						}

					case 'g': // Prefix: "get"

						if l := len("get"); len(elem) >= l && elem[0:l] == "get" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "POST":
								s.handleAPIMassloadInfoGetPostRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "POST")
							}

							return
						}

					case 'l': // Prefix: "list"

						if l := len("list"); len(elem) >= l && elem[0:l] == "list" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "POST":
								s.handleAPIMassloadInfoListPostRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "POST")
							}

							return
						}

					case 'u': // Prefix: "update"

						if l := len("update"); len(elem) >= l && elem[0:l] == "update" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "POST":
								s.handleAPIMassloadInfoUpdatePostRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "POST")
							}

							return
						}

					}

				}

			case 'p': // Prefix: "parsing/"

				if l := len("parsing/"); len(elem) >= l && elem[0:l] == "parsing/" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'h': // Prefix: "handle"

					if l := len("handle"); len(elem) >= l && elem[0:l] == "handle" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "POST":
							s.handleAPIParsingHandlePostRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "POST")
						}

						return
					}

				case 'm': // Prefix: "mirror/"

					if l := len("mirror/"); len(elem) >= l && elem[0:l] == "mirror/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'c': // Prefix: "create"

						if l := len("create"); len(elem) >= l && elem[0:l] == "create" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "POST":
								s.handleAPIParsingMirrorCreatePostRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "POST")
							}

							return
						}

					case 'd': // Prefix: "delete"

						if l := len("delete"); len(elem) >= l && elem[0:l] == "delete" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "POST":
								s.handleAPIParsingMirrorDeletePostRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "POST")
							}

							return
						}

					case 'g': // Prefix: "get"

						if l := len("get"); len(elem) >= l && elem[0:l] == "get" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "POST":
								s.handleAPIParsingMirrorGetPostRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "POST")
							}

							return
						}

					case 'l': // Prefix: "list"

						if l := len("list"); len(elem) >= l && elem[0:l] == "list" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "GET":
								s.handleAPIParsingMirrorListGetRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}

					case 'u': // Prefix: "update"

						if l := len("update"); len(elem) >= l && elem[0:l] == "update" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "POST":
								s.handleAPIParsingMirrorUpdatePostRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "POST")
							}

							return
						}

					}

				}

			case 's': // Prefix: "system/"

				if l := len("system/"); len(elem) >= l && elem[0:l] == "system/" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'i': // Prefix: "i"

					if l := len("i"); len(elem) >= l && elem[0:l] == "i" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'm': // Prefix: "mport/archive"

						if l := len("mport/archive"); len(elem) >= l && elem[0:l] == "mport/archive" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "POST":
								s.handleAPISystemImportArchivePostRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "POST")
							}

							return
						}

					case 'n': // Prefix: "nfo/"

						if l := len("nfo/"); len(elem) >= l && elem[0:l] == "nfo/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 's': // Prefix: "size"

							if l := len("size"); len(elem) >= l && elem[0:l] == "size" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleAPISystemInfoSizeGetRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}

						case 'w': // Prefix: "workers"

							if l := len("workers"); len(elem) >= l && elem[0:l] == "workers" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleAPISystemInfoWorkersGetRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}

						}

					}

				case 't': // Prefix: "task/"

					if l := len("task/"); len(elem) >= l && elem[0:l] == "task/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'c': // Prefix: "create"

						if l := len("create"); len(elem) >= l && elem[0:l] == "create" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "POST":
								s.handleAPISystemTaskCreatePostRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "POST")
							}

							return
						}

					case 'r': // Prefix: "results"

						if l := len("results"); len(elem) >= l && elem[0:l] == "results" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "GET":
								s.handleAPISystemTaskResultsGetRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}

					}

				case 'w': // Prefix: "worker/config"

					if l := len("worker/config"); len(elem) >= l && elem[0:l] == "worker/config" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "POST":
							s.handleAPISystemWorkerConfigPostRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "POST")
						}

						return
					}

				}

			case 'u': // Prefix: "user/login"

				if l := len("user/login"); len(elem) >= l && elem[0:l] == "user/login" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					// Leaf node.
					switch r.Method {
					case "POST":
						s.handleAPIUserLoginPostRequest([0]string{}, elemIsEscaped, w, r)
					default:
						s.notAllowed(w, r, "POST")
					}

					return
				}

			}

		}
	}
	s.notFound(w, r)
}

// Route is route object.
type Route struct {
	name        string
	summary     string
	operationID string
	pathPattern string
	count       int
	args        [1]string
}

// Name returns ogen operation name.
//
// It is guaranteed to be unique and not empty.
func (r Route) Name() string {
	return r.name
}

// Summary returns OpenAPI summary.
func (r Route) Summary() string {
	return r.summary
}

// OperationID returns OpenAPI operationId.
func (r Route) OperationID() string {
	return r.operationID
}

// PathPattern returns OpenAPI path.
func (r Route) PathPattern() string {
	return r.pathPattern
}

// Args returns parsed arguments.
func (r Route) Args() []string {
	return r.args[:r.count]
}

// FindRoute finds Route for given method and path.
//
// Note: this method does not unescape path or handle reserved characters in path properly. Use FindPath instead.
func (s *Server) FindRoute(method, path string) (Route, bool) {
	return s.FindPath(method, &url.URL{Path: path})
}

// FindPath finds Route for given method and URL.
func (s *Server) FindPath(method string, u *url.URL) (r Route, _ bool) {
	var (
		elem = u.Path
		args = r.args
	)
	if rawPath := u.RawPath; rawPath != "" {
		if normalized, ok := uri.NormalizeEscapedPath(rawPath); ok {
			elem = normalized
		}
		defer func() {
			for i, arg := range r.args[:r.count] {
				if unescaped, err := url.PathUnescape(arg); err == nil {
					r.args[i] = unescaped
				}
			}
		}()
	}

	elem, ok := s.cutPrefix(elem)
	if !ok {
		return r, false
	}

	// Static code generated router with unwrapped path search.
	switch {
	default:
		if len(elem) == 0 {
			break
		}
		switch elem[0] {
		case '/': // Prefix: "/api/"

			if l := len("/api/"); len(elem) >= l && elem[0:l] == "/api/" {
				elem = elem[l:]
			} else {
				break
			}

			if len(elem) == 0 {
				break
			}
			switch elem[0] {
			case 'a': // Prefix: "a"

				if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'g': // Prefix: "gent/"

					if l := len("gent/"); len(elem) >= l && elem[0:l] == "gent/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'd': // Prefix: "delete"

						if l := len("delete"); len(elem) >= l && elem[0:l] == "delete" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "POST":
								r.name = APIAgentDeletePostOperation
								r.summary = "Удаление агента"
								r.operationID = ""
								r.pathPattern = "/api/agent/delete"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					case 'g': // Prefix: "get"

						if l := len("get"); len(elem) >= l && elem[0:l] == "get" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "POST":
								r.name = APIAgentGetPostOperation
								r.summary = "Получение данных агента"
								r.operationID = ""
								r.pathPattern = "/api/agent/get"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					case 'l': // Prefix: "list"

						if l := len("list"); len(elem) >= l && elem[0:l] == "list" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "POST":
								r.name = APIAgentListPostOperation
								r.summary = "Список агентов"
								r.operationID = ""
								r.pathPattern = "/api/agent/list"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					case 'n': // Prefix: "new"

						if l := len("new"); len(elem) >= l && elem[0:l] == "new" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "POST":
								r.name = APIAgentNewPostOperation
								r.summary = "Создание нового агента"
								r.operationID = ""
								r.pathPattern = "/api/agent/new"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					case 't': // Prefix: "task/export"

						if l := len("task/export"); len(elem) >= l && elem[0:l] == "task/export" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "POST":
								r.name = APIAgentTaskExportPostOperation
								r.summary = "Экспорт книг в другую систему"
								r.operationID = ""
								r.pathPattern = "/api/agent/task/export"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					case 'u': // Prefix: "update"

						if l := len("update"); len(elem) >= l && elem[0:l] == "update" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "POST":
								r.name = APIAgentUpdatePostOperation
								r.summary = "Обновление данных агента"
								r.operationID = ""
								r.pathPattern = "/api/agent/update"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					}

				case 't': // Prefix: "ttribute/"

					if l := len("ttribute/"); len(elem) >= l && elem[0:l] == "ttribute/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'c': // Prefix: "co"

						if l := len("co"); len(elem) >= l && elem[0:l] == "co" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'l': // Prefix: "lor/"

							if l := len("lor/"); len(elem) >= l && elem[0:l] == "lor/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'c': // Prefix: "create"

								if l := len("create"); len(elem) >= l && elem[0:l] == "create" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "POST":
										r.name = APIAttributeColorCreatePostOperation
										r.summary = "Создание покраски аттрибута"
										r.operationID = ""
										r.pathPattern = "/api/attribute/color/create"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

							case 'd': // Prefix: "delete"

								if l := len("delete"); len(elem) >= l && elem[0:l] == "delete" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "POST":
										r.name = APIAttributeColorDeletePostOperation
										r.summary = "Удаление цвета атрибута"
										r.operationID = ""
										r.pathPattern = "/api/attribute/color/delete"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

							case 'g': // Prefix: "get"

								if l := len("get"); len(elem) >= l && elem[0:l] == "get" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "POST":
										r.name = APIAttributeColorGetPostOperation
										r.summary = "Цвет конкретного атрибута"
										r.operationID = ""
										r.pathPattern = "/api/attribute/color/get"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

							case 'l': // Prefix: "list"

								if l := len("list"); len(elem) >= l && elem[0:l] == "list" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "GET":
										r.name = APIAttributeColorListGetOperation
										r.summary = "Цвета атрибутов"
										r.operationID = ""
										r.pathPattern = "/api/attribute/color/list"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

							case 'u': // Prefix: "update"

								if l := len("update"); len(elem) >= l && elem[0:l] == "update" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "POST":
										r.name = APIAttributeColorUpdatePostOperation
										r.summary = "Обновления покраски атрибута"
										r.operationID = ""
										r.pathPattern = "/api/attribute/color/update"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

							}

						case 'u': // Prefix: "unt"

							if l := len("unt"); len(elem) >= l && elem[0:l] == "unt" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "GET":
									r.name = APIAttributeCountGetOperation
									r.summary = "Количество вариантов атрибутов"
									r.operationID = ""
									r.pathPattern = "/api/attribute/count"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

						}

					case 'o': // Prefix: "origin/count"

						if l := len("origin/count"); len(elem) >= l && elem[0:l] == "origin/count" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "GET":
								r.name = APIAttributeOriginCountGetOperation
								r.summary = "Количество вариантов оригинальных атрибутов"
								r.operationID = ""
								r.pathPattern = "/api/attribute/origin/count"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					case 'r': // Prefix: "remap/"

						if l := len("remap/"); len(elem) >= l && elem[0:l] == "remap/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'c': // Prefix: "create"

							if l := len("create"); len(elem) >= l && elem[0:l] == "create" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "POST":
									r.name = APIAttributeRemapCreatePostOperation
									r.summary = "Создание ремапинга аттрибута"
									r.operationID = ""
									r.pathPattern = "/api/attribute/remap/create"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

						case 'd': // Prefix: "delete"

							if l := len("delete"); len(elem) >= l && elem[0:l] == "delete" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "POST":
									r.name = APIAttributeRemapDeletePostOperation
									r.summary = "Удаление ремапинга атрибута"
									r.operationID = ""
									r.pathPattern = "/api/attribute/remap/delete"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

						case 'g': // Prefix: "get"

							if l := len("get"); len(elem) >= l && elem[0:l] == "get" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "POST":
									r.name = APIAttributeRemapGetPostOperation
									r.summary = "Ремапинг конкретного атрибута"
									r.operationID = ""
									r.pathPattern = "/api/attribute/remap/get"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

						case 'l': // Prefix: "list"

							if l := len("list"); len(elem) >= l && elem[0:l] == "list" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "GET":
									r.name = APIAttributeRemapListGetOperation
									r.summary = "Ремапинги атрибутов"
									r.operationID = ""
									r.pathPattern = "/api/attribute/remap/list"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

						case 'u': // Prefix: "update"

							if l := len("update"); len(elem) >= l && elem[0:l] == "update" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "POST":
									r.name = APIAttributeRemapUpdatePostOperation
									r.summary = "Обновления ремапинга атрибута"
									r.operationID = ""
									r.pathPattern = "/api/attribute/remap/update"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

						}

					}

				}

			case 'b': // Prefix: "book/"

				if l := len("book/"); len(elem) >= l && elem[0:l] == "book/" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'a': // Prefix: "archive/"

					if l := len("archive/"); len(elem) >= l && elem[0:l] == "archive/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "id"
					// Leaf parameter, slashes are prohibited
					idx := strings.IndexByte(elem, '/')
					if idx >= 0 {
						break
					}
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf node.
						switch method {
						case "GET":
							r.name = APIBookArchiveIDGetOperation
							r.summary = "Получение архива с книгой"
							r.operationID = ""
							r.pathPattern = "/api/book/archive/{id}"
							r.args = args
							r.count = 1
							return r, true
						default:
							return
						}
					}

				case 'd': // Prefix: "de"

					if l := len("de"); len(elem) >= l && elem[0:l] == "de" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'l': // Prefix: "lete"

						if l := len("lete"); len(elem) >= l && elem[0:l] == "lete" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "POST":
								r.name = APIBookDeletePostOperation
								r.summary = "Удаляет книгу и/или ее страницы"
								r.operationID = ""
								r.pathPattern = "/api/book/delete"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					case 't': // Prefix: "tails"

						if l := len("tails"); len(elem) >= l && elem[0:l] == "tails" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "POST":
								r.name = APIBookDetailsPostOperation
								r.summary = "Информация о книге"
								r.operationID = ""
								r.pathPattern = "/api/book/details"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					}

				case 'l': // Prefix: "list"

					if l := len("list"); len(elem) >= l && elem[0:l] == "list" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch method {
						case "POST":
							r.name = APIBookListPostOperation
							r.summary = "Список книг"
							r.operationID = ""
							r.pathPattern = "/api/book/list"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}

				case 'p': // Prefix: "page/"

					if l := len("page/"); len(elem) >= l && elem[0:l] == "page/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'b': // Prefix: "body"

						if l := len("body"); len(elem) >= l && elem[0:l] == "body" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "POST":
								r.name = APIBookPageBodyPostOperation
								r.summary = "Получение тела страницы"
								r.operationID = ""
								r.pathPattern = "/api/book/page/body"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					case 'd': // Prefix: "delete"

						if l := len("delete"); len(elem) >= l && elem[0:l] == "delete" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "POST":
								r.name = APIBookPageDeletePostOperation
								r.summary = "Удаляет страницы из книг"
								r.operationID = ""
								r.pathPattern = "/api/book/page/delete"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					}

				case 'r': // Prefix: "r"

					if l := len("r"); len(elem) >= l && elem[0:l] == "r" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'a': // Prefix: "aw"

						if l := len("aw"); len(elem) >= l && elem[0:l] == "aw" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "POST":
								r.name = APIBookRawPostOperation
								r.summary = "Информация о книге"
								r.operationID = ""
								r.pathPattern = "/api/book/raw"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					case 'e': // Prefix: "e"

						if l := len("e"); len(elem) >= l && elem[0:l] == "e" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'b': // Prefix: "build"

							if l := len("build"); len(elem) >= l && elem[0:l] == "build" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "POST":
									r.name = APIBookRebuildPostOperation
									r.summary = "Создает новую книгу из старой"
									r.operationID = ""
									r.pathPattern = "/api/book/rebuild"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

						case 's': // Prefix: "store"

							if l := len("store"); len(elem) >= l && elem[0:l] == "store" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "POST":
									r.name = APIBookRestorePostOperation
									r.summary = "Восстановление удаленной книги или ее страниц"
									r.operationID = ""
									r.pathPattern = "/api/book/restore"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

						}

					}

				case 's': // Prefix: "status/set"

					if l := len("status/set"); len(elem) >= l && elem[0:l] == "status/set" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch method {
						case "POST":
							r.name = APIBookStatusSetPostOperation
							r.summary = "Изменение статуса книги"
							r.operationID = ""
							r.pathPattern = "/api/book/status/set"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}

				case 'u': // Prefix: "update"

					if l := len("update"); len(elem) >= l && elem[0:l] == "update" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch method {
						case "POST":
							r.name = APIBookUpdatePostOperation
							r.summary = "Изменение данных книги"
							r.operationID = ""
							r.pathPattern = "/api/book/update"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}

				}

			case 'd': // Prefix: "deduplicate/"

				if l := len("deduplicate/"); len(elem) >= l && elem[0:l] == "deduplicate/" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'a': // Prefix: "archive"

					if l := len("archive"); len(elem) >= l && elem[0:l] == "archive" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch method {
						case "POST":
							r.name = APIDeduplicateArchivePostOperation
							r.summary = "Проверка наличия данных в системе из архива"
							r.operationID = ""
							r.pathPattern = "/api/deduplicate/archive"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}

				case 'b': // Prefix: "book"

					if l := len("book"); len(elem) >= l && elem[0:l] == "book" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '-': // Prefix: "-by-page-body"

						if l := len("-by-page-body"); len(elem) >= l && elem[0:l] == "-by-page-body" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "POST":
								r.name = APIDeduplicateBookByPageBodyPostOperation
								r.summary = "Поиск дубликатов книги по телу страницы"
								r.operationID = ""
								r.pathPattern = "/api/deduplicate/book-by-page-body"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					case 's': // Prefix: "s-by-page"

						if l := len("s-by-page"); len(elem) >= l && elem[0:l] == "s-by-page" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "POST":
								r.name = APIDeduplicateBooksByPagePostOperation
								r.summary = "Поиск книг содержащих такую же страницу (тело)"
								r.operationID = ""
								r.pathPattern = "/api/deduplicate/books-by-page"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					}

				case 'c': // Prefix: "compare"

					if l := len("compare"); len(elem) >= l && elem[0:l] == "compare" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch method {
						case "POST":
							r.name = APIDeduplicateComparePostOperation
							r.summary = "Сравнение двух книг на дублируемые страницы"
							r.operationID = ""
							r.pathPattern = "/api/deduplicate/compare"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}

				case 'd': // Prefix: "dead-hash/set"

					if l := len("dead-hash/set"); len(elem) >= l && elem[0:l] == "dead-hash/set" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch method {
						case "POST":
							r.name = APIDeduplicateDeadHashSetPostOperation
							r.summary = "Устанавливает значение мертвых хешей для книги или ее страницы"
							r.operationID = ""
							r.pathPattern = "/api/deduplicate/dead-hash/set"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}

				case 'u': // Prefix: "unique-pages"

					if l := len("unique-pages"); len(elem) >= l && elem[0:l] == "unique-pages" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch method {
						case "POST":
							r.name = APIDeduplicateUniquePagesPostOperation
							r.summary = "Поиск уникальных страниц в книге"
							r.operationID = ""
							r.pathPattern = "/api/deduplicate/unique-pages"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}

				}

			case 'f': // Prefix: "f"

				if l := len("f"); len(elem) >= l && elem[0:l] == "f" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'i': // Prefix: "ile/"

					if l := len("ile/"); len(elem) >= l && elem[0:l] == "ile/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "id"
					// Leaf parameter, slashes are prohibited
					idx := strings.IndexByte(elem, '/')
					if idx >= 0 {
						break
					}
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf node.
						switch method {
						case "GET":
							r.name = APIFileIDGetOperation
							r.summary = "Получение тела файла"
							r.operationID = ""
							r.pathPattern = "/api/file/{id}"
							r.args = args
							r.count = 1
							return r, true
						default:
							return
						}
					}

				case 's': // Prefix: "s/"

					if l := len("s/"); len(elem) >= l && elem[0:l] == "s/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'c': // Prefix: "create"

						if l := len("create"); len(elem) >= l && elem[0:l] == "create" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "POST":
								r.name = APIFsCreatePostOperation
								r.summary = "Создание файловой системы"
								r.operationID = ""
								r.pathPattern = "/api/fs/create"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					case 'd': // Prefix: "delete"

						if l := len("delete"); len(elem) >= l && elem[0:l] == "delete" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "POST":
								r.name = APIFsDeletePostOperation
								r.summary = "Удаление файловой системы"
								r.operationID = ""
								r.pathPattern = "/api/fs/delete"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					case 'g': // Prefix: "get"

						if l := len("get"); len(elem) >= l && elem[0:l] == "get" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "POST":
								r.name = APIFsGetPostOperation
								r.summary = "Данные настроек файловой системы"
								r.operationID = ""
								r.pathPattern = "/api/fs/get"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					case 'l': // Prefix: "list"

						if l := len("list"); len(elem) >= l && elem[0:l] == "list" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "POST":
								r.name = APIFsListPostOperation
								r.summary = "Список файловых систем"
								r.operationID = ""
								r.pathPattern = "/api/fs/list"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					case 'r': // Prefix: "remove-mismatch"

						if l := len("remove-mismatch"); len(elem) >= l && elem[0:l] == "remove-mismatch" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "POST":
								r.name = APIFsRemoveMismatchPostOperation
								r.summary = "Запускает задачу удаления не синхронизированных файлов"
								r.operationID = ""
								r.pathPattern = "/api/fs/remove-mismatch"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					case 't': // Prefix: "transfer"

						if l := len("transfer"); len(elem) >= l && elem[0:l] == "transfer" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "POST":
								r.name = APIFsTransferPostOperation
								r.summary = "Запускает перенос файлов между файловыми системами"
								r.operationID = ""
								r.pathPattern = "/api/fs/transfer"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/book"

							if l := len("/book"); len(elem) >= l && elem[0:l] == "/book" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "POST":
									r.name = APIFsTransferBookPostOperation
									r.summary = "Запускает перенос файлов между файловыми системами"
									r.operationID = ""
									r.pathPattern = "/api/fs/transfer/book"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

						}

					case 'u': // Prefix: "update"

						if l := len("update"); len(elem) >= l && elem[0:l] == "update" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "POST":
								r.name = APIFsUpdatePostOperation
								r.summary = "Изменение настроек файловой системы"
								r.operationID = ""
								r.pathPattern = "/api/fs/update"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					case 'v': // Prefix: "validate"

						if l := len("validate"); len(elem) >= l && elem[0:l] == "validate" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "POST":
								r.name = APIFsValidatePostOperation
								r.summary = "Запускает валидацию файлов на файловой системе"
								r.operationID = ""
								r.pathPattern = "/api/fs/validate"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					}

				}

			case 'h': // Prefix: "hproxy/"

				if l := len("hproxy/"); len(elem) >= l && elem[0:l] == "hproxy/" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'b': // Prefix: "book"

					if l := len("book"); len(elem) >= l && elem[0:l] == "book" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch method {
						case "POST":
							r.name = APIHproxyBookPostOperation
							r.summary = "Парсинг данных книги по ссылке"
							r.operationID = ""
							r.pathPattern = "/api/hproxy/book"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}

				case 'f': // Prefix: "file"

					if l := len("file"); len(elem) >= l && elem[0:l] == "file" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch method {
						case "GET":
							r.name = APIHproxyFileGetOperation
							r.summary = "Получение тела файла"
							r.operationID = ""
							r.pathPattern = "/api/hproxy/file"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}

				case 'l': // Prefix: "list"

					if l := len("list"); len(elem) >= l && elem[0:l] == "list" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch method {
						case "POST":
							r.name = APIHproxyListPostOperation
							r.summary = "Парсинг списка данных по ссылке"
							r.operationID = ""
							r.pathPattern = "/api/hproxy/list"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}

				}

			case 'l': // Prefix: "label/"

				if l := len("label/"); len(elem) >= l && elem[0:l] == "label/" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'd': // Prefix: "delete"

					if l := len("delete"); len(elem) >= l && elem[0:l] == "delete" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch method {
						case "POST":
							r.name = APILabelDeletePostOperation
							r.summary = "Удаление метки"
							r.operationID = ""
							r.pathPattern = "/api/label/delete"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}

				case 'g': // Prefix: "get"

					if l := len("get"); len(elem) >= l && elem[0:l] == "get" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch method {
						case "POST":
							r.name = APILabelGetPostOperation
							r.summary = "Получение меток книги"
							r.operationID = ""
							r.pathPattern = "/api/label/get"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}

				case 'p': // Prefix: "preset/"

					if l := len("preset/"); len(elem) >= l && elem[0:l] == "preset/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'c': // Prefix: "create"

						if l := len("create"); len(elem) >= l && elem[0:l] == "create" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "POST":
								r.name = APILabelPresetCreatePostOperation
								r.summary = "Создание пресета меток"
								r.operationID = ""
								r.pathPattern = "/api/label/preset/create"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					case 'd': // Prefix: "delete"

						if l := len("delete"); len(elem) >= l && elem[0:l] == "delete" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "POST":
								r.name = APILabelPresetDeletePostOperation
								r.summary = "Удаление пресета меток"
								r.operationID = ""
								r.pathPattern = "/api/label/preset/delete"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					case 'g': // Prefix: "get"

						if l := len("get"); len(elem) >= l && elem[0:l] == "get" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "POST":
								r.name = APILabelPresetGetPostOperation
								r.summary = "Пресеты меток"
								r.operationID = ""
								r.pathPattern = "/api/label/preset/get"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					case 'l': // Prefix: "list"

						if l := len("list"); len(elem) >= l && elem[0:l] == "list" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "GET":
								r.name = APILabelPresetListGetOperation
								r.summary = "Пресеты меток"
								r.operationID = ""
								r.pathPattern = "/api/label/preset/list"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					case 'u': // Prefix: "update"

						if l := len("update"); len(elem) >= l && elem[0:l] == "update" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "POST":
								r.name = APILabelPresetUpdatePostOperation
								r.summary = "Обновления пресета меток"
								r.operationID = ""
								r.pathPattern = "/api/label/preset/update"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					}

				case 's': // Prefix: "set"

					if l := len("set"); len(elem) >= l && elem[0:l] == "set" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch method {
						case "POST":
							r.name = APILabelSetPostOperation
							r.summary = "Установка метки"
							r.operationID = ""
							r.pathPattern = "/api/label/set"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}

				}

			case 'm': // Prefix: "massload/"

				if l := len("massload/"); len(elem) >= l && elem[0:l] == "massload/" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'f': // Prefix: "flag/"

					if l := len("flag/"); len(elem) >= l && elem[0:l] == "flag/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'c': // Prefix: "create"

						if l := len("create"); len(elem) >= l && elem[0:l] == "create" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "POST":
								r.name = APIMassloadFlagCreatePostOperation
								r.summary = "Создание информации о флаге массовой загрузке"
								r.operationID = ""
								r.pathPattern = "/api/massload/flag/create"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					case 'd': // Prefix: "delete"

						if l := len("delete"); len(elem) >= l && elem[0:l] == "delete" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "POST":
								r.name = APIMassloadFlagDeletePostOperation
								r.summary = "Удаление флага массовой загрузки"
								r.operationID = ""
								r.pathPattern = "/api/massload/flag/delete"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					case 'g': // Prefix: "get"

						if l := len("get"); len(elem) >= l && elem[0:l] == "get" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "POST":
								r.name = APIMassloadFlagGetPostOperation
								r.summary = "Получение флага массовой загрузки"
								r.operationID = ""
								r.pathPattern = "/api/massload/flag/get"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					case 'l': // Prefix: "list"

						if l := len("list"); len(elem) >= l && elem[0:l] == "list" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "GET":
								r.name = APIMassloadFlagListGetOperation
								r.summary = "Флаги для массовых загрузок"
								r.operationID = ""
								r.pathPattern = "/api/massload/flag/list"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					case 'u': // Prefix: "update"

						if l := len("update"); len(elem) >= l && elem[0:l] == "update" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "POST":
								r.name = APIMassloadFlagUpdatePostOperation
								r.summary = "Обновление флага массовой загрузки"
								r.operationID = ""
								r.pathPattern = "/api/massload/flag/update"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					}

				case 'i': // Prefix: "info/"

					if l := len("info/"); len(elem) >= l && elem[0:l] == "info/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'a': // Prefix: "attribute/"

						if l := len("attribute/"); len(elem) >= l && elem[0:l] == "attribute/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'c': // Prefix: "create"

							if l := len("create"); len(elem) >= l && elem[0:l] == "create" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "POST":
									r.name = APIMassloadInfoAttributeCreatePostOperation
									r.summary = "Привязка аттрибута к массовой загрузке"
									r.operationID = ""
									r.pathPattern = "/api/massload/info/attribute/create"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

						case 'd': // Prefix: "delete"

							if l := len("delete"); len(elem) >= l && elem[0:l] == "delete" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "POST":
									r.name = APIMassloadInfoAttributeDeletePostOperation
									r.summary = "Удаление аттрибута для массовой загрузки"
									r.operationID = ""
									r.pathPattern = "/api/massload/info/attribute/delete"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

						}

					case 'c': // Prefix: "create"

						if l := len("create"); len(elem) >= l && elem[0:l] == "create" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "POST":
								r.name = APIMassloadInfoCreatePostOperation
								r.summary = "Создание информации о массовой загрузке"
								r.operationID = ""
								r.pathPattern = "/api/massload/info/create"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					case 'd': // Prefix: "delete"

						if l := len("delete"); len(elem) >= l && elem[0:l] == "delete" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "POST":
								r.name = APIMassloadInfoDeletePostOperation
								r.summary = "Удаление массовой загрузки"
								r.operationID = ""
								r.pathPattern = "/api/massload/info/delete"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					case 'e': // Prefix: "external_link/"

						if l := len("external_link/"); len(elem) >= l && elem[0:l] == "external_link/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'c': // Prefix: "create"

							if l := len("create"); len(elem) >= l && elem[0:l] == "create" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "POST":
									r.name = APIMassloadInfoExternalLinkCreatePostOperation
									r.summary = "Привязка внешней ссылки к массовой загрузке"
									r.operationID = ""
									r.pathPattern = "/api/massload/info/external_link/create"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

						case 'd': // Prefix: "delete"

							if l := len("delete"); len(elem) >= l && elem[0:l] == "delete" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "POST":
									r.name = APIMassloadInfoExternalLinkDeletePostOperation
									r.summary = "Удаление внешней ссылки для массовой загрузки"
									r.operationID = ""
									r.pathPattern = "/api/massload/info/external_link/delete"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

						case 'u': // Prefix: "update"

							if l := len("update"); len(elem) >= l && elem[0:l] == "update" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "POST":
									r.name = APIMassloadInfoExternalLinkUpdatePostOperation
									r.summary = "Обновление внешней ссылки массовой загрузки"
									r.operationID = ""
									r.pathPattern = "/api/massload/info/external_link/update"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

						}

					case 'g': // Prefix: "get"

						if l := len("get"); len(elem) >= l && elem[0:l] == "get" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "POST":
								r.name = APIMassloadInfoGetPostOperation
								r.summary = "Получение массовой загрузки"
								r.operationID = ""
								r.pathPattern = "/api/massload/info/get"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					case 'l': // Prefix: "list"

						if l := len("list"); len(elem) >= l && elem[0:l] == "list" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "POST":
								r.name = APIMassloadInfoListPostOperation
								r.summary = "Массовые загрузки"
								r.operationID = ""
								r.pathPattern = "/api/massload/info/list"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					case 'u': // Prefix: "update"

						if l := len("update"); len(elem) >= l && elem[0:l] == "update" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "POST":
								r.name = APIMassloadInfoUpdatePostOperation
								r.summary = "Обновление массовой загрузки"
								r.operationID = ""
								r.pathPattern = "/api/massload/info/update"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					}

				}

			case 'p': // Prefix: "parsing/"

				if l := len("parsing/"); len(elem) >= l && elem[0:l] == "parsing/" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'h': // Prefix: "handle"

					if l := len("handle"); len(elem) >= l && elem[0:l] == "handle" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch method {
						case "POST":
							r.name = APIParsingHandlePostOperation
							r.summary = "Обработка ссылок на новые книги"
							r.operationID = ""
							r.pathPattern = "/api/parsing/handle"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}

				case 'm': // Prefix: "mirror/"

					if l := len("mirror/"); len(elem) >= l && elem[0:l] == "mirror/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'c': // Prefix: "create"

						if l := len("create"); len(elem) >= l && elem[0:l] == "create" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "POST":
								r.name = APIParsingMirrorCreatePostOperation
								r.summary = "Создание данных зеркала"
								r.operationID = ""
								r.pathPattern = "/api/parsing/mirror/create"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					case 'd': // Prefix: "delete"

						if l := len("delete"); len(elem) >= l && elem[0:l] == "delete" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "POST":
								r.name = APIParsingMirrorDeletePostOperation
								r.summary = "Удаление зеркала"
								r.operationID = ""
								r.pathPattern = "/api/parsing/mirror/delete"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					case 'g': // Prefix: "get"

						if l := len("get"); len(elem) >= l && elem[0:l] == "get" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "POST":
								r.name = APIParsingMirrorGetPostOperation
								r.summary = "Получение данных зеркала"
								r.operationID = ""
								r.pathPattern = "/api/parsing/mirror/get"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					case 'l': // Prefix: "list"

						if l := len("list"); len(elem) >= l && elem[0:l] == "list" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "GET":
								r.name = APIParsingMirrorListGetOperation
								r.summary = "Зеркала"
								r.operationID = ""
								r.pathPattern = "/api/parsing/mirror/list"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					case 'u': // Prefix: "update"

						if l := len("update"); len(elem) >= l && elem[0:l] == "update" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "POST":
								r.name = APIParsingMirrorUpdatePostOperation
								r.summary = "Обновления зеркала"
								r.operationID = ""
								r.pathPattern = "/api/parsing/mirror/update"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					}

				}

			case 's': // Prefix: "system/"

				if l := len("system/"); len(elem) >= l && elem[0:l] == "system/" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'i': // Prefix: "i"

					if l := len("i"); len(elem) >= l && elem[0:l] == "i" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'm': // Prefix: "mport/archive"

						if l := len("mport/archive"); len(elem) >= l && elem[0:l] == "mport/archive" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "POST":
								r.name = APISystemImportArchivePostOperation
								r.summary = "Импорт новой книги"
								r.operationID = ""
								r.pathPattern = "/api/system/import/archive"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					case 'n': // Prefix: "nfo/"

						if l := len("nfo/"); len(elem) >= l && elem[0:l] == "nfo/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 's': // Prefix: "size"

							if l := len("size"); len(elem) >= l && elem[0:l] == "size" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "GET":
									r.name = APISystemInfoSizeGetOperation
									r.summary = "Текущее состояние системы"
									r.operationID = ""
									r.pathPattern = "/api/system/info/size"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

						case 'w': // Prefix: "workers"

							if l := len("workers"); len(elem) >= l && elem[0:l] == "workers" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "GET":
									r.name = APISystemInfoWorkersGetOperation
									r.summary = "Текущее состояние воркеров системы"
									r.operationID = ""
									r.pathPattern = "/api/system/info/workers"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

						}

					}

				case 't': // Prefix: "task/"

					if l := len("task/"); len(elem) >= l && elem[0:l] == "task/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'c': // Prefix: "create"

						if l := len("create"); len(elem) >= l && elem[0:l] == "create" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "POST":
								r.name = APISystemTaskCreatePostOperation
								r.summary = "Создание и запуск задачи"
								r.operationID = ""
								r.pathPattern = "/api/system/task/create"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					case 'r': // Prefix: "results"

						if l := len("results"); len(elem) >= l && elem[0:l] == "results" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "GET":
								r.name = APISystemTaskResultsGetOperation
								r.summary = "Получение результатов задач"
								r.operationID = ""
								r.pathPattern = "/api/system/task/results"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					}

				case 'w': // Prefix: "worker/config"

					if l := len("worker/config"); len(elem) >= l && elem[0:l] == "worker/config" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch method {
						case "POST":
							r.name = APISystemWorkerConfigPostOperation
							r.summary = "Динамическая конфигурация раннеров (воркеров)"
							r.operationID = ""
							r.pathPattern = "/api/system/worker/config"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}

				}

			case 'u': // Prefix: "user/login"

				if l := len("user/login"); len(elem) >= l && elem[0:l] == "user/login" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					// Leaf node.
					switch method {
					case "POST":
						r.name = APIUserLoginPostOperation
						r.summary = "Проставление токена в куки"
						r.operationID = ""
						r.pathPattern = "/api/user/login"
						r.args = args
						r.count = 0
						return r, true
					default:
						return
					}
				}

			}

		}
	}
	return r, false
}
